package main

import (
	"flag"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/ngicks/estype/fielddatatype/estime"
	builtinlayouts "github.com/ngicks/estype/fielddatatype/estime/builtin_layouts"
	"github.com/ngicks/estype/generator/genestime"
	"github.com/ngicks/estype/helper/util"
	"github.com/ngicks/und/option"
)

var (
	outFile = flag.String("o", "", "")
)

func main() {
	flag.Parse()

	out := util.OpenOutMust(*outFile)
	defer out.Close()

	f := jen.NewFilePath("github.com/ngicks/estype/fielddatatype/estime/builtin")
	f.HeaderComment("// Code generated by github.com/ngicks/estype/generator/genestime/gen_builtin/gen.go. DO NOT EDIT.")
	f.PackageComment("//go:generate go run ../../../generator/genestime/gen_builtin/gen.go -o builtin.go")

	pascalCase := func(snakeCase string) string {
		out := ""
		for _, part := range strings.Split(snakeCase, "_") {
			out += strings.ToUpper(part[:1]) + part[1:]
		}
		return out
	}

	// "strict_date_optional_time||epoch_millis"
	f.Commentf(
		"// %s is time.Time based type which can be directly marshalled to / unmarshaled from\n"+
			"// Elasticsearch default date format, \"%s\".",
		"Default", "strict_date_optional_time||epoch_millis",
	)
	genestime.GeneratorDef{
		TyName:      "Default",
		MultiLayout: builtinlayouts.BuiltinLayouts["strict_date_optional_time"],
		NumParser:   estime.Millis,
		Comment:     option.Some[string](""),
	}.Gen(f)

	f.Commentf(
		"// %s is time.Time based type which can be directly marshalled to / unmarshaled from\n"+
			"// Elasticsearch default date format, \"%s\".\n"+
			"// This is almost identical to Default but it marshals into JSON number.",

		"DefaultNum", "strict_date_optional_time||epoch_millis",
	)
	genestime.GeneratorDef{
		TyName:          "DefaultNum",
		MultiLayout:     builtinlayouts.BuiltinLayouts["strict_date_optional_time"],
		NumParser:       estime.Millis,
		MarshalToNumber: true,
		Comment:         option.Some[string](""),
	}.Gen(f)

	//  "strict_date_optional_time_nanos||epoch_millis"
	f.Commentf(
		"// %s is time.Time based type which can be directly marshalled to / unmarshaled from\n"+
			"// Elasticsearch default date format, \"%s\".\n"+
			"// This is nano sec precise counterpart of Default.",
		"DefaultNano", "strict_date_optional_time_nanos||epoch_millis",
	)
	genestime.GeneratorDef{
		TyName:      "DefaultNano",
		MultiLayout: builtinlayouts.BuiltinLayouts["strict_date_optional_time_nanos"],
		NumParser:   estime.Millis,
		Comment:     option.Some[string](""),
	}.Gen(f)

	f.Commentf(
		"// %s is time.Time based type which can be directly marshalled to / unmarshaled from\n"+
			"// Elasticsearch default date format, \"%s\".\n"+
			"// This is nano sec precise counterpart of DefaultNum.",
		"DefaultNumNano", "strict_date_optional_time_nanos||epoch_millis",
	)
	genestime.GeneratorDef{
		TyName:          "DefaultNumNano",
		MultiLayout:     builtinlayouts.BuiltinLayouts["strict_date_optional_time_nanos"],
		NumParser:       estime.Millis,
		MarshalToNumber: true,
		Comment:         option.Some[string](""),
	}.Gen(f)

	for _, numFormat := range builtinlayouts.BuiltinFormats[:2] {
		f.Commentf(
			"// %s is time.Time based type which can be directly marshalled to / unmarshaled from\n"+
				"// the built-in date format, \"%s\".",
			pascalCase(numFormat), numFormat,
		)
		numParser := estime.Millis
		if numFormat == string(estime.Second) {
			numParser = estime.Second
		}
		def := genestime.GeneratorDef{
			TyName:          pascalCase(numFormat),
			NumParser:       numParser,
			MarshalToNumber: true,
			Comment:         option.Some[string](""),
		}
		def.Gen(f)
	}
	for _, format := range builtinlayouts.BuiltinFormats[2:] {
		layouts, ok := builtinlayouts.BuiltinLayouts[format]
		if !ok {
			continue
		}

		f.Commentf(
			"// %s is time.Time based type which can be directly marshalled to / unmarshaled from\n"+
				"// the built-in format, \"%s\"",
			pascalCase(format), format,
		)
		def := genestime.GeneratorDef{
			TyName:      pascalCase(format),
			MultiLayout: layouts,
			Comment:     option.Some[string](""),
		}
		def.Gen(f)
	}

	if err := f.Render(out); err != nil {
		panic(err)
	}
}
